package init

//
//import (
//	"Compiler/src/ast"
//	"Compiler/src/ast/expression/lvalue/reference"
//	"Compiler/src/ast/expression/rvalue/binOperateResult"
//	"Compiler/src/ast/expression/rvalue/doubleLiteral"
//	"Compiler/src/ast/expression/rvalue/intLiteral"
//	stmt "Compiler/src/ast/statement"
//	"Compiler/src/ast/statement/assign"
//	"Compiler/src/ast/statement/compound"
//	"Compiler/src/symbolTable"
//	"Compiler/src/symbolTable/symbol"
//)
//
//type s struct {
//	node ast.Node
//}
//
//var result *compound.CompoundStmt
//
//function test()  {
//	//var nodes ast.Node
//	var nodes stmt.Stmt
//	nodes = compound.CreateCompoundStmt()
//	nodes
//	compound.AddStmt(result, $2)
//	s := symbol.CreateSymbol(true, 1,"2")
//	symbolTable.AddSymbol(s)
//	ref := reference.CreateVariableReference(s)
//	assign.CreateAssignStmt(ref, 1)
//
//	sb := symbolTable.GetVarSymbol("1")
//	ref := reference.CreateVariableReference(sb)
//	assign.CreateAssignStmt(ref, )
//
//	intLiteral.CreateIntLiteral()
//	doubleLiteral.CreateDoubleLiteral($1)
//	binOperateResult.CreateBinOperateResult(1, )
//}
//
//function test() {
//	var s *stmt.Stmt
//	v := s.(ast.Node)
//
//	x := v.(stmt.Stmt)
////	lvalue.LValue()
//}

func test() {
	//var x uint8
	//y,_ := strconv.ParseUint("a", 10, 8)
	//x = uint8(y)
	//stmt.CreateAssignStmt()
	//stmt.Stmt
	//function.CreateFuncDefine()
	//funcdef.Function{}
	//declare.CreateDeclareStmt(s, assign.AssignStmt{})
	//symbolTable.PushFrame()
	//declare.DeclareStmt{}
	//function.CreateFuncDefine(1,"1", nil, nil)
	//var v5 interface{}
	//v5 = 1
	//reference.CreateVariableReference()
}
